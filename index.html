import React, { useState, useEffect, useRef } from 'react';
import { 
  Upload, FileText, Moon, Download, RefreshCw, X, 
  Image as ImageIcon, Settings, CheckCircle, AlertCircle, 
  Loader2, Grid, Layers, Trash2, LayoutTemplate, 
  Menu, CheckSquare, Square, ChevronDown, ChevronUp
} from 'lucide-react';

// --- Configuration ---
const APP_NAME = "SynapseLearn";
const PDFJS_URL = "https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js";
const PDFJS_WORKER_URL = "https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js";
const JSPDF_URL = "https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js";

// --- Hooks ---
const useScript = (url) => {
  const [status, setStatus] = useState(url ? "loading" : "idle");
  useEffect(() => {
    if (!url) { setStatus("idle"); return; }
    let script = document.querySelector(`script[src="${url}"]`);
    if (!script) {
      script = document.createElement("script");
      script.src = url;
      script.async = true;
      script.setAttribute("data-status", "loading");
      document.body.appendChild(script);
      const setAttributeFromEvent = (event) => {
        script.setAttribute("data-status", event.type === "load" ? "ready" : "error");
        setStatus(event.type === "load" ? "ready" : "error");
      };
      script.addEventListener("load", setAttributeFromEvent);
      script.addEventListener("error", setAttributeFromEvent);
    } else {
      setStatus(script.getAttribute("data-status"));
    }
    const setStateFromEvent = (event) => setStatus(event.type === "load" ? "ready" : "error");
    script.addEventListener("load", setStateFromEvent);
    script.addEventListener("error", setStateFromEvent);
    return () => {
      if (script) {
        script.removeEventListener("load", setStateFromEvent);
        script.removeEventListener("error", setStateFromEvent);
      }
    };
  }, [url]);
  return status;
};

export default function SynapseLearnMobile() {
  const pdfJsStatus = useScript(PDFJS_URL);
  const jsPdfStatus = useScript(JSPDF_URL);
  const [isEngineReady, setIsEngineReady] = useState(false);

  // --- State ---
  const [files, setFiles] = useState([]);
  const [pages, setPages] = useState([]); 
  const [viewMode, setViewMode] = useState('single'); // 'single' | 'grid'
  const [currentPreviewIndex, setCurrentPreviewIndex] = useState(0);
  const [isProcessing, setIsProcessing] = useState(false);
  const [processingProgress, setProcessingProgress] = useState(0);
  const [logs, setLogs] = useState([]);
  const [mobileMenuOpen, setMobileMenuOpen] = useState(false);
  
  // --- Settings ---
  const [settings, setSettings] = useState({
    invert: true,
    grayscale: false,
    brightness: 0,
    contrast: 0,
    removeBackground: false,
    threshold: 200,
    layoutConfig: 1, // 1, 2, 3, 4, 6, 9
  });

  const addLog = (msg, type = 'info') => {
    setLogs(prev => [`[${new Date().toLocaleTimeString()}] ${msg}`, ...prev]);
    if (type === 'error') console.error(msg);
  };

  // --- Init ---
  useEffect(() => {
    if (pdfJsStatus === "ready" && jsPdfStatus === "ready" && window.pdfjsLib) {
      window.pdfjsLib.GlobalWorkerOptions.workerSrc = PDFJS_WORKER_URL;
      setIsEngineReady(true);
    }
  }, [pdfJsStatus, jsPdfStatus]);

  // --- Core Logic ---
  const handleFiles = async (newFiles) => {
    if (!newFiles || newFiles.length === 0) return;
    setIsProcessing(true);
    setMobileMenuOpen(false); // Close menu on mobile after select
    
    const fileArray = Array.from(newFiles).filter(f => f.type === "application/pdf");
    if (fileArray.length === 0) {
        addLog("Invalid file type. Please upload PDFs.", "error");
        setIsProcessing(false);
        return;
    }

    const updatedFiles = [...files, ...fileArray];
    setFiles(updatedFiles);

    let newPagesList = [...pages];
    let startingGlobalIndex = pages.length;

    for (const file of fileArray) {
        try {
            const arrayBuffer = await file.arrayBuffer();
            const pdfDoc = await window.pdfjsLib.getDocument({ data: arrayBuffer }).promise;
            
            for (let i = 1; i <= pdfDoc.numPages; i++) {
                newPagesList.push({
                    globalId: `f${updatedFiles.indexOf(file)}-p${i}-${Date.now()}-${Math.random()}`,
                    fileIndex: updatedFiles.indexOf(file),
                    fileName: file.name,
                    pdfDoc: pdfDoc,
                    pageIndex: i,
                    selected: true,
                    thumbnail: null
                });
            }
        } catch (err) {
            addLog(`Error loading ${file.name}`, "error");
        }
    }

    setPages(newPagesList);
    setIsProcessing(false);
    
    // Generate thumbnails for a few initial pages
    generateThumbnails(newPagesList.slice(startingGlobalIndex, startingGlobalIndex + 6));
  };

  const generateThumbnails = async (targetPages) => {
      const { invert, grayscale, contrast, brightness } = settings;
      
      for (const p of targetPages) {
          if (p.thumbnail) continue; 
          try {
              const page = await p.pdfDoc.getPage(p.pageIndex);
              // Use slightly higher scale for better visibility
              const viewport = page.getViewport({ scale: 0.4 }); 
              const canvas = document.createElement("canvas");
              const ctx = canvas.getContext("2d");
              canvas.height = viewport.height;
              canvas.width = viewport.width;

              // CRITICAL: Draw white background first so transparent PDFs aren't invisible
              ctx.fillStyle = "#FFFFFF";
              ctx.fillRect(0, 0, canvas.width, canvas.height);

              await page.render({ canvasContext: ctx, viewport }).promise;
              
              // Apply simple preview filter if needed (optional for thumbnails, keeps them fast)
              // We'll skip complex filters on thumbnails for performance, but simple invert helps visual context
              if (invert) {
                  ctx.globalCompositeOperation = 'difference';
                  ctx.fillStyle = 'white';
                  ctx.fillRect(0, 0, canvas.width, canvas.height);
              }

              const thumbUrl = canvas.toDataURL();
              setPages(prev => prev.map(item => item.globalId === p.globalId ? { ...item, thumbnail: thumbUrl } : item));
          } catch(e) { console.warn("Thumb error", e); }
      }
  };

  // Re-generate thumbnails if invert changes (for better UX)
  useEffect(() => {
     // Reset thumbnails so they regenerate with new visual style
     setPages(prev => prev.map(p => ({...p, thumbnail: null})));
     // Trigger regeneration for visible range (simplified here to first 20)
     const timer = setTimeout(() => {
        generateThumbnails(pages.slice(0, 20));
     }, 500);
     return () => clearTimeout(timer);
  }, [settings.invert]);


  const applyFilters = (imageData, config) => {
    const data = new Uint8ClampedArray(imageData.data); 
    const { invert, grayscale, brightness, contrast, removeBackground, threshold } = config;
    const contrastFactor = (259 * (contrast + 255)) / (255 * (259 - contrast));
    
    for (let i = 0; i < data.length; i += 4) {
      let r = data[i], g = data[i + 1], b = data[i + 2];

      if (invert) { r = 255 - r; g = 255 - g; b = 255 - b; }
      if (grayscale) { const avg = 0.3 * r + 0.59 * g + 0.11 * b; r = avg; g = avg; b = avg; }
      if (contrast !== 0) {
        r = contrastFactor * (r - 128) + 128;
        g = contrastFactor * (g - 128) + 128;
        b = contrastFactor * (b - 128) + 128;
      }
      if (brightness !== 0) { r += brightness; g += brightness; b += brightness; }
      if (removeBackground) {
         if (r > threshold && g > threshold && b > threshold) { r = 255; g = 255; b = 255; }
      }
      data[i] = Math.max(0, Math.min(255, r));
      data[i+1] = Math.max(0, Math.min(255, g));
      data[i+2] = Math.max(0, Math.min(255, b));
    }
    return new ImageData(data, imageData.width, imageData.height);
  };

  const [activePreviewUrl, setActivePreviewUrl] = useState(null);
  
  // Single Preview Renderer
  useEffect(() => {
    const renderPreview = async () => {
        if (pages.length === 0) return;
        const currentPage = pages[currentPreviewIndex];
        if (!currentPage) return;
        try {
            const page = await currentPage.pdfDoc.getPage(currentPage.pageIndex);
            const viewport = page.getViewport({ scale: 1.0 });
            const canvas = document.createElement("canvas");
            const ctx = canvas.getContext("2d");
            canvas.width = viewport.width;
            canvas.height = viewport.height;
            
            // White bg
            ctx.fillStyle = "#FFFFFF";
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            await page.render({ canvasContext: ctx, viewport }).promise;
            
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const processed = applyFilters(imageData, settings);
            ctx.putImageData(processed, 0, 0);
            setActivePreviewUrl(canvas.toDataURL("image/jpeg", 0.9));
        } catch (e) {}
    };
    renderPreview();
  }, [currentPreviewIndex, pages.length, settings]);

  // --- PDF Export Engine ---
  const processAndDownload = async () => {
    setIsProcessing(true);
    setProcessingProgress(0);
    const activePages = pages.filter(p => p.selected);
    
    if (activePages.length === 0) {
        addLog("No slides selected!", "error");
        setIsProcessing(false);
        return;
    }

    try {
        const { jsPDF } = window.jspdf;
        const doc = new jsPDF('p', 'pt', 'a4'); 
        const docW = doc.internal.pageSize.getWidth();
        const docH = doc.internal.pageSize.getHeight();
        
        // --- Grid Logic ---
        // Defines how many rows and cols for each setting
        const layoutMap = {
            1: { cols: 1, rows: 1 },
            2: { cols: 1, rows: 2 },
            3: { cols: 1, rows: 3 },
            4: { cols: 2, rows: 2 },
            6: { cols: 2, rows: 3 },
            9: { cols: 3, rows: 3 },
        };
        const layout = layoutMap[settings.layoutConfig] || layoutMap[1];
        const slidesPerPage = layout.cols * layout.rows;
        
        // Calculate cell dimensions (maximize space, no margins between cells if possible)
        const cellW = docW / layout.cols;
        const cellH = docH / layout.rows;

        for (let i = 0; i < activePages.length; i++) {
            const p = activePages[i];
            setProcessingProgress(Math.round((i / activePages.length) * 100));
            
            // New page check
            if (i > 0 && i % slidesPerPage === 0) {
                doc.addPage();
            }

            // Render
            const page = await p.pdfDoc.getPage(p.pageIndex);
            const viewport = page.getViewport({ scale: 1.5 });
            const canvas = document.createElement("canvas");
            const ctx = canvas.getContext("2d");
            canvas.width = viewport.width;
            canvas.height = viewport.height;
            
            // White bg first
            ctx.fillStyle = "#FFFFFF";
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            await page.render({ canvasContext: ctx, viewport }).promise;
            
            // Filter
            const rawData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const filtered = applyFilters(rawData, settings);
            ctx.putImageData(filtered, 0, 0);
            const imgData = canvas.toDataURL("image/jpeg", 0.85);

            // Calculate Position
            const indexOnPage = i % slidesPerPage;
            const col = indexOnPage % layout.cols;
            const row = Math.floor(indexOnPage / layout.cols);
            
            const xBase = col * cellW;
            const yBase = row * cellH;

            // Fit image into cell while maintaining aspect ratio
            const ratioW = cellW / viewport.width;
            const ratioH = cellH / viewport.height;
            const ratio = Math.min(ratioW, ratioH);
            
            const finalW = viewport.width * ratio;
            const finalH = viewport.height * ratio;
            
            // Center in cell
            const xOffset = xBase + (cellW - finalW) / 2;
            const yOffset = yBase + (cellH - finalH) / 2;

            doc.addImage(imgData, 'JPEG', xOffset, yOffset, finalW, finalH);
            
            // Pause for UI
            await new Promise(r => setTimeout(r, 0));
        }

        setProcessingProgress(100);
        doc.save(`${APP_NAME}_Export.pdf`);
    } catch (err) {
        addLog(`Export Error: ${err.message}`, "error");
    } finally {
        setIsProcessing(false);
    }
  };

  const selectAll = () => setPages(p => p.map(x => ({...x, selected: true})));
  const selectNone = () => setPages(p => p.map(x => ({...x, selected: false})));
  const toggleSelect = (id) => setPages(p => p.map(x => x.globalId === id ? {...x, selected: !x.selected} : x));

  // --- Render ---
  if (!isEngineReady) return <div className="flex h-screen items-center justify-center bg-gray-950 text-white"><Loader2 className="animate-spin mr-2"/> Loading Engine...</div>;

  return (
    <div className="flex flex-col lg:flex-row h-screen bg-gray-900 text-gray-100 font-sans overflow-hidden">
      
      {/* --- MOBILE HEADER --- */}
      <div className="lg:hidden h-16 bg-gray-950 border-b border-gray-800 flex items-center justify-between px-4 shrink-0 z-30">
          <div className="flex items-center gap-2 font-bold text-lg">
             <Layers className="text-blue-500"/> {APP_NAME}
          </div>
          <button onClick={() => setMobileMenuOpen(!mobileMenuOpen)} className="p-2 bg-gray-900 rounded border border-gray-700">
             <Menu size={20}/>
          </button>
      </div>

      {/* --- SIDEBAR (Controls) --- */}
      <aside className={`
        fixed inset-0 z-40 bg-gray-950 flex flex-col transition-transform duration-300
        lg:relative lg:translate-x-0 lg:w-80 lg:border-r lg:border-gray-800 lg:shadow-xl
        ${mobileMenuOpen ? 'translate-x-0' : '-translate-x-full'}
      `}>
         {/* Mobile Close Button */}
         <div className="lg:hidden p-4 flex justify-end">
             <button onClick={() => setMobileMenuOpen(false)}><X size={24}/></button>
         </div>

         {/* Desktop Header */}
         <div className="hidden lg:flex p-5 border-b border-gray-800 bg-gradient-to-r from-gray-950 to-gray-900 items-center gap-2">
            <Layers className="text-blue-500"/>
            <h1 className="font-bold">{APP_NAME}</h1>
         </div>

         {/* Scrollable Settings */}
         <div className="flex-1 overflow-y-auto p-5 space-y-6">
            
            {/* 1. Files */}
            <div>
                <h3 className="text-xs font-bold text-gray-500 uppercase tracking-widest mb-3 flex items-center gap-2"><FileText size={12}/> Input</h3>
                <div className="border-2 border-dashed border-gray-800 hover:border-blue-500 rounded-xl p-4 text-center cursor-pointer transition-colors bg-gray-900/50">
                    <input type="file" id="file-upload" multiple accept="application/pdf" className="hidden" onChange={(e) => handleFiles(e.target.files)} />
                    <label htmlFor="file-upload" className="cursor-pointer block">
                        <Upload className="mx-auto text-blue-500 mb-2"/>
                        <span className="text-sm font-medium">Add PDF Files</span>
                        <p className="text-[10px] text-gray-500 mt-1">Select multiple at once</p>
                    </label>
                </div>
                <div className="mt-3 space-y-1">
                    {files.map((f, i) => (
                        <div key={i} className="flex justify-between text-xs bg-gray-900 p-2 rounded border border-gray-800">
                            <span className="truncate w-48">{f.name}</span>
                            <button onClick={() => {
                                setFiles(prev => prev.filter((_, idx) => idx !== i));
                                setPages(prev => prev.filter(p => p.fileIndex !== i));
                            }} className="text-red-400 hover:text-red-300"><Trash2 size={12}/></button>
                        </div>
                    ))}
                </div>
            </div>

            {/* 2. Visual Filters */}
            <div className={`transition-opacity duration-500 ${files.length ? 'opacity-100' : 'opacity-50 pointer-events-none'}`}>
                 <div className="flex justify-between items-center mb-3">
                    <h3 className="text-xs font-bold text-gray-500 uppercase tracking-widest flex items-center gap-2"><Settings size={12}/> Filters</h3>
                    <button onClick={() => setSettings(s => ({...s, invert: true, grayscale: false, brightness: 0, contrast: 0}))}><RefreshCw size={12} className="text-gray-600 hover:text-white"/></button>
                 </div>
                 
                 <div className="grid grid-cols-2 gap-2 mb-4">
                    <button onClick={() => setSettings(s => ({...s, invert: !s.invert}))} 
                        className={`p-3 rounded border flex flex-col items-center gap-1 ${settings.invert ? 'bg-blue-900/30 border-blue-500 text-blue-300' : 'bg-gray-900 border-gray-800'}`}>
                        <Moon size={16}/> <span className="text-[10px]">Invert</span>
                    </button>
                    <button onClick={() => setSettings(s => ({...s, grayscale: !s.grayscale}))} 
                        className={`p-3 rounded border flex flex-col items-center gap-1 ${settings.grayscale ? 'bg-blue-900/30 border-blue-500 text-blue-300' : 'bg-gray-900 border-gray-800'}`}>
                        <ImageIcon size={16}/> <span className="text-[10px]">Grayscale</span>
                    </button>
                 </div>
                 
                 <div className="space-y-3">
                    <div>
                        <div className="flex justify-between text-[10px] text-gray-400 uppercase"><span>Contrast</span> <span>{settings.contrast}</span></div>
                        <input type="range" min="-100" max="100" value={settings.contrast} onChange={(e) => setSettings(s => ({...s, contrast: parseInt(e.target.value)}))} className="w-full h-1 bg-gray-800 rounded appearance-none cursor-pointer accent-blue-500"/>
                    </div>
                    <div>
                         <div className="flex justify-between text-[10px] text-gray-400 uppercase"><span>Brightness</span> <span>{settings.brightness}</span></div>
                         <input type="range" min="-100" max="100" value={settings.brightness} onChange={(e) => setSettings(s => ({...s, brightness: parseInt(e.target.value)}))} className="w-full h-1 bg-gray-800 rounded appearance-none cursor-pointer accent-blue-500"/>
                    </div>
                 </div>
            </div>

            {/* 3. Output Layout */}
            <div className={`transition-opacity duration-500 ${files.length ? 'opacity-100' : 'opacity-50 pointer-events-none'}`}>
                <h3 className="text-xs font-bold text-gray-500 uppercase tracking-widest mb-3 flex items-center gap-2"><LayoutTemplate size={12}/> Layout</h3>
                <div className="grid grid-cols-3 gap-2">
                    {[1, 2, 3, 4, 6, 9].map(n => (
                        <button 
                            key={n}
                            onClick={() => setSettings(s => ({...s, layoutConfig: n}))}
                            className={`py-2 text-xs font-bold rounded border ${settings.layoutConfig === n ? 'bg-blue-600 text-white border-blue-600' : 'bg-gray-900 border-gray-800 text-gray-400'}`}
                        >
                            {n}-Up
                        </button>
                    ))}
                </div>
                <p className="text-[10px] text-gray-500 mt-2 text-center">
                    {settings.layoutConfig === 1 ? "Full Page Slide" : 
                     settings.layoutConfig === 2 ? "2 Rows (Stacked)" : 
                     settings.layoutConfig === 3 ? "3 Rows (Stacked)" :
                     `${settings.layoutConfig} Slides Grid`}
                </p>
            </div>
         </div>

         {/* Export Action */}
         <div className="p-5 border-t border-gray-800 bg-gray-950">
             <button 
                onClick={processAndDownload}
                disabled={files.length === 0 || isProcessing}
                className="w-full py-3 rounded-lg font-bold flex items-center justify-center gap-2 bg-gradient-to-r from-blue-600 to-indigo-600 hover:from-blue-500 hover:to-indigo-500 disabled:opacity-50 disabled:cursor-not-allowed shadow-lg shadow-blue-900/20 text-white"
             >
                 {isProcessing ? <Loader2 className="animate-spin"/> : <Download size={18}/>}
                 {isProcessing ? "Working..." : "Export PDF"}
             </button>
         </div>
      </aside>

      {/* --- MAIN AREA --- */}
      <main className="flex-1 flex flex-col relative bg-gray-900 min-w-0">
          
          {/* Top Bar (View Modes) */}
          <div className="h-14 bg-gray-900/90 backdrop-blur border-b border-gray-800 flex items-center justify-between px-4 shrink-0">
             <div className="flex bg-gray-950 p-1 rounded-lg border border-gray-800">
                <button onClick={() => setViewMode('single')} className={`px-3 py-1.5 rounded text-xs font-medium flex gap-2 ${viewMode === 'single' ? 'bg-gray-800 text-white shadow' : 'text-gray-400'}`}>
                    <FileText size={14} className="hidden sm:block"/> Preview
                </button>
                <button onClick={() => { setViewMode('grid'); generateThumbnails(pages.slice(0, 30)); }} className={`px-3 py-1.5 rounded text-xs font-medium flex gap-2 ${viewMode === 'grid' ? 'bg-gray-800 text-white shadow' : 'text-gray-400'}`}>
                    <Grid size={14} className="hidden sm:block"/> Grid Manager
                </button>
             </div>
             <div className="text-xs text-gray-400 flex items-center gap-2">
                 <span className="hidden sm:inline">Selected:</span> 
                 <span className="bg-blue-900/30 text-blue-300 px-2 py-0.5 rounded border border-blue-900/50">{pages.filter(p=>p.selected).length} / {pages.length}</span>
             </div>
          </div>

          {/* Content Viewport */}
          <div className="flex-1 overflow-hidden relative">
              
              {/* VIEW: Single */}
              {viewMode === 'single' && (
                  <div className="w-full h-full bg-[radial-gradient(#1f2937_1px,transparent_1px)] [background-size:16px_16px] flex flex-col items-center p-4 overflow-y-auto">
                      {pages.length > 0 ? (
                        <>
                           <div className="relative shadow-2xl bg-white max-w-full lg:max-w-2xl w-full">
                               {activePreviewUrl ? (
                                   <img src={activePreviewUrl} alt="Preview" className="w-full h-auto block" />
                               ) : (
                                   <div className="aspect-[1/1.4] bg-gray-800 flex items-center justify-center text-gray-500 animate-pulse">Rendering...</div>
                               )}
                           </div>
                           
                           {/* Floating Nav */}
                           <div className="fixed bottom-6 bg-gray-900/90 backdrop-blur border border-gray-700 rounded-full px-4 py-2 flex gap-4 text-white shadow-xl z-20">
                               <button onClick={() => setCurrentPreviewIndex(Math.max(0, currentPreviewIndex - 1))} className="hover:text-blue-400"><ChevronDown className="rotate-90"/></button>
                               <span className="text-sm font-mono pt-0.5">{currentPreviewIndex + 1} / {pages.length}</span>
                               <button onClick={() => setCurrentPreviewIndex(Math.min(pages.length - 1, currentPreviewIndex + 1))} className="hover:text-blue-400"><ChevronDown className="-rotate-90"/></button>
                           </div>
                        </>
                      ) : (
                          <div className="flex flex-col items-center justify-center h-full text-gray-600">
                              <FileText size={64} className="mb-4 opacity-20"/>
                              <p>No document loaded</p>
                              <button onClick={() => setMobileMenuOpen(true)} className="mt-4 text-blue-500 text-sm lg:hidden">Open Menu to Upload</button>
                          </div>
                      )}
                  </div>
              )}

              {/* VIEW: Grid Manager */}
              {viewMode === 'grid' && (
                  <div className="w-full h-full flex flex-col">
                      {/* Grid Tools */}
                      <div className="h-10 bg-gray-950 border-b border-gray-800 flex items-center px-4 gap-4 text-xs">
                          <button onClick={selectAll} className="flex items-center gap-1 hover:text-white text-gray-400"><CheckSquare size={14}/> All</button>
                          <button onClick={selectNone} className="flex items-center gap-1 hover:text-white text-gray-400"><Square size={14}/> None</button>
                      </div>
                      
                      {/* Grid Scroll Area */}
                      <div className="flex-1 overflow-y-auto p-4 custom-scrollbar">
                         {pages.length === 0 ? <div className="text-center mt-20 text-gray-600">No slides to manage</div> : (
                             <div className="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 lg:grid-cols-5 xl:grid-cols-6 gap-3 pb-20">
                                {pages.map(p => (
                                    <div 
                                        key={p.globalId} 
                                        onClick={() => toggleSelect(p.globalId)}
                                        className={`relative aspect-[1/1.3] rounded-lg border-2 cursor-pointer overflow-hidden transition-all group
                                        ${p.selected ? "border-blue-500 bg-blue-500/10" : "border-gray-800 opacity-60 bg-gray-900"}
                                        `}
                                    >
                                        {/* Thumbnail Image */}
                                        {p.thumbnail ? (
                                            <img src={p.thumbnail} className="w-full h-full object-contain bg-gray-800" alt="slide"/>
                                        ) : (
                                            <div className="w-full h-full flex items-center justify-center text-[10px] text-gray-600">Loading...</div>
                                        )}
                                        
                                        {/* Checkbox Overlay */}
                                        <div className={`absolute top-2 right-2 w-5 h-5 rounded-full flex items-center justify-center border shadow-sm transition-colors ${p.selected ? 'bg-blue-500 border-blue-500 text-white' : 'bg-gray-900/80 border-gray-500'}`}>
                                            {p.selected && <CheckCircle size={12}/>}
                                        </div>
                                        
                                        {/* Page Number */}
                                        <div className="absolute bottom-1 right-2 text-[10px] bg-black/50 px-1.5 rounded text-gray-300">
                                            {p.pageIndex}
                                        </div>
                                    </div>
                                ))}
                             </div>
                         )}
                      </div>
                      {/* Load More Trigger (Invisible) - Could implement infinite scroll here */}
                  </div>
              )}

              {/* Processing Overlay */}
              {isProcessing && (
                  <div className="absolute inset-0 z-50 bg-gray-900/90 backdrop-blur flex items-center justify-center p-6">
                      <div className="w-full max-w-sm bg-gray-950 border border-gray-800 rounded-2xl p-6 text-center shadow-2xl">
                          <Loader2 className="w-10 h-10 text-blue-500 animate-spin mx-auto mb-4"/>
                          <h3 className="text-lg font-bold text-white">Processing PDF</h3>
                          <p className="text-sm text-gray-400 mb-6">Optimizing layout and applying filters...</p>
                          <div className="h-2 bg-gray-900 rounded-full overflow-hidden">
                              <div className="h-full bg-blue-500 transition-all duration-300" style={{width: `${processingProgress}%`}}/>
                          </div>
                          <p className="text-xs text-right mt-2 text-blue-400 font-mono">{processingProgress}%</p>
                      </div>
                  </div>
              )}
          </div>
      </main>

      <style>{`
        .custom-scrollbar::-webkit-scrollbar { width: 4px; }
        .custom-scrollbar::-webkit-scrollbar-thumb { background: #4b5563; border-radius: 4px; }
      `}</style>
    </div>
  );
}